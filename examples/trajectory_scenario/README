INTRODUCTION
    This example illustrates a scenario where a manipulator if to be
    controlled by a node in a ROS system. The two components are
    designed i such a way that the mapping between the interfaces are
    especially bad. This is done to showcase two features of the
    bridge generator:

    * Conversion

      When the data model of two systems are different, how should
      fields in one model map to the field in the other?

    * Trigger Policy

      When combining multiple data sources, which one should trigger
      the transmission of the outgoing message(s)?

RUNNING
    Start the controller ROS-node:

        $ rosrun ros_trajectory_generator_mock main.py

    Create the bridge:

        $ rosrun generator generator.py -c lc_trajectory_user/conf.xml

    Compile the LabComm types which the external program uses for communication,
    and also those imposed by the bridge (when using the default
    method of interaction). This is part of the external program and handled by
    a makefile:

        $ make -C lc_trajectory_user

    Start the bridge (which the config names 'traj'):

        $ rosrun traj main.py

    Start the external program:

        $ lc_trajectory_user/src/main.py

TODO
    Use static connections to show how to use an existing client which
    has no knowledge about the bridge?
